### c++中调用c的接口

```c++
extern "c" void func();   // 调用方式一，单个函数


#ifdef __cplusplus  // 是c++编译器定义的宏
extern "c"
{
#endif
   // 需要添加的代码    // 可能是包含多个函数的头文件、多个头文件
 
#ifdef __cplusplus
}
#endif
```

> 为什么要设置接口？
>
> 在c中已经有比较成熟的一些函数、功能，在c++中可以通过某些接口、设置直接使用c类型的函数等
>
> 关于extern "c"{   }？
>
> 1. 核心作用：实现C和C++的混合编程。extern “C”提供一个链接交换指定符号，用于告诉C++这段函数是C函数，extern “C”后面的函数不使用C++的名字修饰，而是使用C
>
> 2. C++支持函数重载，C不支持函数重载。函数被C++编译后在库中的名字与C语言不同。如void add(int a, int b)，该函数在C编译器编译后，库中名字为_add，而C++编译器则会生成add_int_int的名字。故C++提供C链接交换指定符号extern “C”来解决名字匹配问题

### c++11的新特性

> 1983年，“带类的C"正式被称为“c++"
>
> 1998年，c++发布了第一版c++标准， 即c++98
>
> 之后的发展主要是：c++11、c++14、c++17

- auto类型推导的语法和规则

  - auto相当于占位符，当不清楚变量的类型时，可以用auto关键字来指定——等价于让编译器自己推导变量的类型。

  - 必须是对变量的初始化，否则无法推导出变量的类

    ```c++
    void func(auto a){  //  auto不能用作函数参数
        
    }
    
    class A{
        auto a = 1; // auto不能用做非静态成员变量
        static auto b = 2;
        static const auto int c = 1;
        
    }
    ```

- 智能指针

- `for(auto i : vectore_A)`循环遍历

- 空指针为 nullptr 而不是0，避免了歧义

